# Examples

Here are some more complete examples on how you'd use the SDK to interact, and we'll focus on dApps.

## Minting into kiosk example

For every scenario when we're using Kiosk in dApps, the user who has connected their wallet will
either have a kiosk already (and could have more than one) or we will have to create it for them.

The SDK supports the scenario of `silently` creating the kiosk, as part of our PTBs.

Let's assume that the mint function of the contract is:

`public fun mint(coin: Coin<SUI>, kiosk: &mut Kiosk, cap: &KioskOwnerCap){...}`

### When the user has a kiosk

```typescript

// let's assume that we have created the client somewhere else.
const kioskClient = new KioskClient({...});
const connectedAddress = '0xAnAddress';

// This function should run when the user connects the wallet.
// We should re-use the same `KioskClient` instance throughout our dApp.
const prepareClient = async () => {
    let { kioskOwnerCaps } = await kioskClient.getOwnedKiosks(address);
    // let's assume that the user has only 1 kiosk.
    // Here, we would need to do some more checks in a realistic scneario.
    // And also possible give the user in our dApp a selector for which kiosk he wants to interact with
    // (if he owns more than 1).
    kioskClient.setSelectedCap(kioskOwnerCaps[0])
}

// Now our mint function would be like:
const mint = async () => {
    const txb = new TransactionBlock();

    // This would work in both personal and non-personal kiosks.
    await kioskClient.ownedKioskTx(txb, async (kiosk, cap) => {
        // We'll assume it costs 1 SUI
        let coin = txb.splitCoins(txb.gas, [tx.pure(1_000_000_000)]);

        txb.moveCall({
            target: '0xMyGame::hero::mint',
            arguments: [
                coin, // the payment
                kiosk, // our kiosk that the hero will be placed in
                cap // our kiosk cap, so that the function can place or lock it.
            ]
        });
    });
    // now we can continue to sign & execute the transaction.
}
```

### When the user doesn't have a kiosk (silent creation)

```typescript
// let's assume that we have created the client somewhere else.
const kioskClient = new KioskClient({...});

// Our mint function.
const mint = async () => {
    // let's assume this is the connected address. If we were using wallet-kit, that would be `currentAccount?.address`.
    const connectedAddress = '0xAnAddress';
    const txb = new TransactionBlock();

    // Create function creates a kiosk and the owner Cap.
    const [kiosk, cap] = kioskClient.create(txb);

  
    // we prepare the coin object for the payment. (assume it costs 1 SUI to mint a hero)
    let coin = txb.splitCoins(txb.gas, [tx.pure(1_000_000_000)]);

    // now let's mint a hero.
    txb.moveCall({
        target: '0xMyGame::hero::mint',
        arguments: [
            coin, // the payment
            kiosk, // We can pass in the kiosk we just created
            cap // We can also pass in the cap.
        ]
    });

    // We need to share + transfer the cap for the newly created kiosk.
    txb.shareAndTransferCap(txb, kiosk, cap, connectedAddress);

    // we can now signAndExecute the transaction!
}
```

## Borrowing an item from kiosk to do an action

```typescript
// let's assume that we have created the client somewhere else.
const kioskClient = new KioskClient({...});
// let's assume `selectedCap` is set by kioskClient.setSelectedCap(kioskOwnerCaps), similar to first example.

const levelUp = async () => {

    const txb = new TransactionBlock();

    const item = {
        type: '0x2MyGame::hero::Hero',
        objectId: '0xMyHeroObjectId'
    };

    await kioskClient.ownedKioskTx(txb, (kiosk, capObject) => {

        // approach 1: Callback
        kioskClient.borrowTx(txb, item.type, item.objectId, kiosk, capObject, (item) => {
            txb.moveCall({
                target: '0xMyGame::hero::level_up',
                arguments: [item],
            });
        });

        // approach 2: Borrow + return
        const [item, promise] = kioskClient.borrow(txb, item.type, item.objectId, kiosk, capObject);

        txb.moveCall({
            target: '0xMyGame::hero::level_up',
            arguments: [item],
        });

        kioskClient.return(txb, item.type, item, promise, kiosk);

        // now we can continue to sign & execute the transaction.
    });
}
```
